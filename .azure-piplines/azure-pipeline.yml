trigger: 
 - none

parameters:
- name: buildImage
  type: boolean
  default: false
  displayName: 'Upadet Imaage?'
- name: PIPELINE_VARIABLES_PATH # in case there are multiple env subfolders inside pipelines/variables folder, e.g. pipelines/variables/dev or pipelines/variables/prod
  type: string
  default: 'storage'
- name: DESTROY_TF
  type: boolean
  default: false
- name: runValidateLintCheckov
  displayName: 'Run validate, lint, and checkov stage'
  type: boolean
  default: true
- name: Create_Backend_Storage
  type: boolean
  default: false
- name: environment
  type: string
  default: dev
  value:
    - dev
    - prod

variables:
  - group: vmSecrets
  - template: ${{ parameters['PIPELINE_VARIABLES_PATH'] }}/variables.yaml@self 

pool:
  vmImage: 'ubuntu-latest'

stages:
- stage: Install_Pipeline_Dependencies
  displayName: 'Install Pipeline Dependencies'
  condition: and(not(failed()), not(canceled()))
  variables:
  - name: ROOT_PATH
    value: '$(System.DefaultWorkingDirectory)'
  jobs: 
  - template: templates/pipeline_dependencies.yaml

- stage: terraform_destroy
  dependsOn: Install_Pipeline_Dependencies
  condition: and(not(failed()), not(canceled()), eq('${{ parameters.DESTROY_TF }}', 'true'))
  displayName: TF destroy
  jobs:
  - job: 'TF_destroy_plan'
    steps:
    - task: AzureCLI@2
      displayName: Deploy Linux Agent ACI
      inputs:
        azureSubscription: ${{ variables.backend_service_connection_name }}
        workingDirectory: ${{ variables.terraform_path }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          terraform workspace select ${{ parameters.environment }}

    - task: TerraformCLI@0
      displayName: Terraform init
      inputs:
        command: 'init'
        workingDirectory: ${{ variables.terraform_path }}
        backendType: 'azurerm'
        backendServiceArm: ${{ variables.backend_service_connection_name }}
        backendAzureRmSubscriptionId: ${{ variables.backend_subscription_id }}
        ensureBackend: true
        backendAzureRmResourceGroupName: ${{ variables.backend_resource_group_name }}
        backendAzureRmResourceGroupLocation: ${{ variables.backend_resource_group_location }}
        backendAzureRmStorageAccountName: ${{ variables.backend_storage_account_name }}
        backendAzureRmContainerName: ${{ variables.backend_storage_container_name }}
        workspaceName: ${{ parameters.environment }}

        allowTelemetryCollection: true
    - task: TerraformCLI@0
      displayName: Terraform destroy plan
      inputs:
        command: 'plan'
        workingDirectory: ${{ variables.terraform_path }}
        environmentServiceName: ${{ variables.target_service_connection_name }}
        allowTelemetryCollection: false
        commandOptions: '-destroy -out=tfplan.destroy -var-file="${{ variables.terraform_path }}${{ parameters.environment }}.tfvars" -var resource_group_name=$(RG_NAME) -var admin_username=$(VMUSER) -var source_image_id=$(imageId) '
        publishPlanResults: 'Plan-Destroy'
    - task: PublishPipelineArtifact@1
      displayName: 'Upload Terraform Destroy Plan'
      inputs:
        targetPath: ${{ variables.target_tfvars_path }}
        artifact: 'tf-artifact'
        publishLocation: 'pipeline'
  - job: 'Destroy_Manual_Validation'
    displayName: 'Wait for External Validation Before Destroy'  
    dependsOn: TF_destroy_plan
    pool: server 
    timeoutInMinutes: 4320 # job times out in 3 days.
    steps:
    - task: ManualValidation@0
      timeoutInMinutes: 1440 # task times out in 1 day
      inputs:
        notifyUsers: ${{ variables.notify_email }}
        instructions: 'Please validate the intention to destroy resources and resume/reject as appropriate. The environment to be destroyed is ${{ variables.backend_storage_container_name }} / ${{ variables.backend_tfstate_file_name }}.'
        onTimeout: 'reject'
  - job: 'TF_destroy'
    dependsOn: Destroy_Manual_Validation
    steps:  
    - task: TerraformCLI@0
      displayName: Terraform init
      inputs:
        command: 'init'
        workingDirectory: ${{ variables.target_tfvars_path }}
        backendType: 'azurerm'
        backendServiceArm: ${{ variables.backend_service_connection_name }}
        backendAzureRmSubscriptionId: ${{ variables.backend_subscription_id }}
        ensureBackend: true
        backendAzureRmResourceGroupName: ${{ variables.backend_resource_group_name }}
        backendAzureRmResourceGroupLocation: ${{ variables.backend_resource_group_location }}
        backendAzureRmStorageAccountName: ${{ variables.backend_storage_account_name }}
        backendAzureRmContainerName: ${{ variables.backend_storage_container_name }}
        workspaceName: ${{ parameters.environment }}
        allowTelemetryCollection: true
    - task: TerraformCLI@0
      displayName: Terraform destroy
      inputs:
        command: 'destroy'
        workingDirectory: ${{variables.target_tfvars_path }}
        environmentServiceName: '${{ variables.target_service_connection_name  }}'
        commandOptions: '-var resource_group_name=$(RG_NAME) -var admin_username=$(VMUSER) -var source_image_id=$(imageId) -var-file="${{ variables.target_tfvars_path }}${{ parameters.environment }}.tfvars" -auto-approve'
        allowTelemetryCollection: true

- stage: "Create_Backend_Storage"
  condition: eq('${{ parameters.Create_Backend_Storage }}', 'true')
  displayName: "Create Backend Storage"
  dependsOn: Install_Pipeline_Dependencies
  jobs:
  - job: 'Create_Storage'
    displayName: "Create Storage"
    steps:
    - task: AzureCLI@2
      name: Create_Account
      displayName: 'Create_Account'
      inputs:
        azureSubscription: ${{ variables.backend_service_connection_name }}
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az account set --subscription ${{ variables.backend_subscription_id }}
          az storage account create --name ${{ variables.backend_storage_account_name }} --resource-group ${{ variables.backend_resource_group_name }} --encryption-services blob --default-action Allow --kind StorageV2
          az storage container create --name ${{variables.backend_storage_container_name }} --account-name ${{ variables.backend_storage_account_name }}

- stage: BuildImage
  displayName: 'Build Linux Image'
  condition: eq('${{ parameters.buildImage }}', true)
  jobs:
  - job: 'Build_Image'
    displayName: "Build Image"
    steps:
    - task: AzureCLI@2
      displayName: Validating Packer
      inputs:
        azureSubscription: ${{ variables.backend_service_connection_name }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          if [[ $(az group exists --name $(RG_NAME)) == true ]]; then
            echo "Resource group already exists."
          else
            az group create --location $(LOCATION) --name $(RG_NAME)
          fi
      
    - task: replacetokens@6
      name: replacePackerTokens
      displayName: 'Replace tokens in packer file'
      inputs:
        root: '$(System.DefaultWorkingDirectory)/image'
        sources: 'pkr_azure_ubuntu_image.pkr.hcl'
        tokenPattern: 'azpipelines'

    - task: replacetokens@6
      name: replaceUsername
      displayName: 'Replace Username'
      inputs:
        root: '$(System.DefaultWorkingDirectory)/image/scripts'
        sources: '02_ubuntu_docker.sh'
        tokenPattern: 'azpipelines'
            
    - task: AzureCLI@2
      name: BuildImageC
      displayName: Build Image
      inputs:
        azureSubscription: ${{ variables.backend_service_connection_name }}
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
                packer init image/
                packer build "$(System.DefaultWorkingDirectory)/image/pkr_azure_ubuntu_image.pkr.hcl" 
                Start-Sleep -Seconds 10
                
    - task: AzureCLI@2
      name: A
      displayName: 'Set ImageId variable'
      inputs:
        azureSubscription: ${{ variables.target_service_connection_name }}
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          az extension add --name azure-devops
          az config set extension.use_dynamic_install=yes_without_prompt
          echo $(System.AccessToken) | az devops login
          
          variableGroupId=$(az pipelines variable-group list --group-name vmsecrets --org $(System.CollectionUri) --project $(DevopsProjectName) --query "[0].id" -o json)
          echo "##vso[task.setvariable variable=variableGroupId;isOutput=true]$variableGroupId"
          
          imageResId=$(az resource show -g $RG_NAME --name $IMAGE_NAME --resource-type "Microsoft.Compute/images" --query "id" -o tsv)
          # Set the Image Resource ID in the Azure DevOps variable group
          az pipelines variable-group variable update --project DevOpsDevil --group-id $variableGroupId --name ImageId --value $imageResId || \
          az pipelines variable-group variable create --project DevOpsDevil --group-id $variableGroupId --name ImageId --value $imageResId
          az devops logout

- stage: "validate_lint_checkov"
  displayName: "TF code validation and scanner"
  condition: and(not(failed()), not(canceled()), eq('${{ parameters.DESTROY_TF }}', 'false'), eq('${{ parameters.runValidateLintCheckov }}', 'true'))
  dependsOn: BuildImage
  jobs:
  - job: ''
    displayName: "Tf validate"
    continueOnError: false
    steps:
    - task: TerraformCLI@0
      displayName: Terraform init
      inputs:
        command: 'init'
        workingDirectory: ${{ variables.terraform_path }}
        backendType: 'azurerm'
        backendServiceArm: ${{ variables.backend_service_connection_name }}
        backendAzureRmSubscriptionId: ${{ variables.backend_subscription_id }}
        ensureBackend: true
        backendAzureRmResourceGroupName: ${{ variables.backend_resource_group_name }}
        backendAzureRmResourceGroupLocation: ${{ variables.backend_resource_group_location }}
        backendAzureRmStorageAccountName: ${{ variables.backend_storage_account_name }}
        backendAzureRmContainerName: ${{ variables.backend_storage_container_name }}
        backendAzureRmKey: ${{ variables.default_tfstate_file_name }}
        allowTelemetryCollection: true
    - task: TerraformCLI@0
      displayName: "Tf validate"
      inputs:
        command: 'validate'
        environmentServiceName: ${{ variables.target_service_connection_name  }}
        allowTelemetryCollection: false
  - job: tflint
    displayName: "TF lint scan"
    #condition: eq('${{ parameters.Lint_Run }}', 'true')
    steps:
    - task: CmdLine@2
      name: tflint_run
      displayName: 'Initialize and run tflint'
      inputs:
        workingDirectory: ${{ variables.terraform_path }}
        script: |
          echo -e "\n##[command]Initializing tflint plugins:"
          tflint --init --config=./.azure-pipelines/config_files/.tflint.hcl
          echo -e "\n##[command]Running tflint --config=./.azure-pipelines/config_files/.tflint.hcl --no-color --module --format=default | tee tflint.report.txt:"
          tflint --config=./.azure-pipelines/config_files/.tflint.hcl --no-color --module --format=default | tee tflint.report.txt
          echo -e "##[command]Done."
          echo "##vso[task.setvariable variable=publish_tflint;]false"
          if [[ $(find ${{ variables.terraform_path }}/tflint.report.txt -type f -size +1c 2>/dev/null) ]]; then
            cp ${{ variables.terraform_path }}/tflint.report.txt $(Build.ArtifactStagingDirectory) >> /dev/null 2>&1
            echo -e "\n##[command]Tflint report will be published as there are some findings."
            echo "##vso[task.setvariable variable=publish_tflint;]true"
          else
            echo -e "\n##[command]Tflint report will not be published as there are no findings."
          fi
  - job: "terraform_check"
    displayName: "TF Checkov scan"
    #condition: eq('${{ parameters.Checkov_Run }}', 'true')
    steps:
    - task: Bash@3
      displayName: "Pull > bridgecrew/checkov"
      inputs:
        targetType: inline
        script: |
          sudo docker pull bridgecrew/checkov
        workingDirectory: ${{ variables.terraform_path }}
    - task: Bash@3
      displayName: "Run > checkov"
      inputs:
        targetType: inline
        script: |
          sudo docker run --volume $(pwd):/tf bridgecrew/checkov --directory /tf --output junitxml --soft-fail > $(pwd)/CheckovReport.xml
        workingDirectory: ${{ variables.terraform_path }}
    - task: PublishTestResults@2
      inputs:
        testRunTitle: "Checkov Results"
        failTaskOnFailedTests: false
        testResultsFormat: "JUnit"
        testResultsFiles: "CheckovReport.xml"
        searchFolder: "${{ variables.terraform_path }}"
      displayName: "Publish > Checkov scan results"

- stage: terraform_plan
  dependsOn: validate_lint_checkov
  condition: and(not(failed()), not(canceled()), eq('${{ parameters.DESTROY_TF }}', 'false'))
  displayName: TF plan
  jobs:
  - job: 'TF_Plan'
    steps:
    - task: TerraformCLI@0
      displayName: Terraform init
      inputs:
        command: 'init'
        workingDirectory: ${{ variables.terraform_path }}
        backendType: 'azurerm'
        backendServiceArm: ${{ variables.backend_service_connection_name }}
        backendAzureRmSubscriptionId: ${{ variables.backend_subscription_id }}
        ensureBackend: true
        backendAzureRmResourceGroupName: ${{ variables.backend_resource_group_name }}
        backendAzureRmResourceGroupLocation: ${{ variables.backend_resource_group_location }}
        backendAzureRmStorageAccountName: ${{ variables.backend_storage_account_name }}
        backendAzureRmContainerName: ${{ variables.backend_storage_container_name }}
        backendAzureRmKey: ${{ variables.default_tfstate_file_name }}
        allowTelemetryCollection: true
    - task: AzureCLI@2
      displayName: Deploy Linux Agent ACI
      inputs:
        azureSubscription: ${{ variables.backend_service_connection_name }}
        workingDirectory: ${{ variables.terraform_path }}
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          terraform workspace select ${{ parameters.environment }} || terraform workspace new ${{ parameters.environment }}
    - task: TerraformCLI@0
      displayName: Terraform init
      inputs:
        command: 'init'
        workingDirectory: ${{ variables.terraform_path }}
        backendType: 'azurerm'
        backendServiceArm: ${{ variables.backend_service_connection_name }}
        backendAzureRmSubscriptionId: ${{ variables.backend_subscription_id }}
        ensureBackend: true
        backendAzureRmResourceGroupName: ${{ variables.backend_resource_group_name }}
        backendAzureRmResourceGroupLocation: ${{ variables.backend_resource_group_location }}
        backendAzureRmStorageAccountName: ${{ variables.backend_storage_account_name }}
        backendAzureRmContainerName: ${{ variables.backend_storage_container_name }}
        workspaceName: ${{ parameters.environment }}
        allowTelemetryCollection: true

    - task: TerraformCLI@0
      displayName: Terraform plan
      inputs:
        command: 'plan'
        workingDirectory: ${{ variables.terraform_path }}
        environmentServiceName: '${{ variables.target_service_connection_name }}'
        commandOptions: -var resource_group_name=$(RG_NAME) -var admin_username=$(VMUSER) -var source_image_id=$(imageId) -var-file="${{ variables.target_tfvars_path }}${{parameters.environment}}.tfvars"
        allowTelemetryCollection: true
        publishPlanResults: 'Terraform Plan'

    - task: PublishPipelineArtifact@1
      name: Publish_Terraform_Plan
      displayName: 'Publish terraform plan'
      inputs:
        targetPath: ${{ variables.terraform_path }}
        artifactName: 'terraform.tfplan'
        publishLocation: 'pipeline'    

- stage: terraform_apply
  condition: and(not(failed()), not(canceled()), eq('${{ parameters.DESTROY_TF }}', 'false'))
  dependsOn: terraform_plan
  displayName: TF apply
  jobs:
  - deployment: 'Apply_Manual_Validation'
    displayName: 'Wait for External Validation Before Apply' 
    environment: dummy 
    pool: server 
    timeoutInMinutes: 4320 # job times out in 3 days.
    strategy:
      runOnce:
        deploy:
          steps:
          - task: ManualValidation@0
            timeoutInMinutes: 1440 # task times out in 1 day
            inputs:
              notifyUsers: ${{ variables.notify_email }}
              instructions: 'Please validate the intention to Apply resources and resume/reject as appropriate.'
              onTimeout: 'reject'
  - job: 'TF_apply'
    dependsOn: Apply_Manual_Validation
    condition: succeeded()
    steps:
    - task: replacetokens@6
      name: replacePackerTokens
      displayName: 'Replace tokens in cloud-init.yml'
      inputs:
        root: '${{ variables.terraform_path }}/config'
        sources: 'cloud-init.yaml'
        tokenPattern: 'doubleunderscores'
    - task: TerraformCLI@0
      displayName: Terraform init
      inputs:
        command: 'init'
        workingDirectory: ${{ variables.terraform_path }}
        backendType: 'azurerm'
        backendServiceArm: ${{ variables.backend_service_connection_name }}
        backendAzureRmSubscriptionId: ${{ variables.backend_subscription_id }}
        ensureBackend: true
        backendAzureRmResourceGroupName: ${{ variables.backend_resource_group_name }}
        backendAzureRmResourceGroupLocation: ${{ variables.backend_resource_group_location }}
        backendAzureRmStorageAccountName: ${{ variables.backend_storage_account_name }}
        backendAzureRmContainerName: ${{ variables.backend_storage_container_name }}
        workspaceName: ${{ parameters.environment }}
        allowTelemetryCollection: true

    - task: TerraformCLI@0
      displayName: Terraform apply
      inputs:
        command: 'apply'
        allowTelemetryCollection: false
        workingDirectory: ${{ variables.terraform_path }}
        environmentServiceName: '${{ variables.target_service_connection_name }}'
        commandOptions: -var resource_group_name=$(RG_NAME) -var admin_username=$(VMUSER) -var source_image_id=$(imageId) -var-file="${{ variables.target_tfvars_path }}${{parameters.environment}}.tfvars"
    - script: |
           sleep 60 
      displayName: 'Waiting for agent to become online'
   
  - job: Ansible
    displayName: Configure agent as a service
    dependsOn: TF_apply
    pool:
      name: 'master-pool' 
    steps:        
      - script: |
          if ! command -v ansible &> /dev/null
          then
              sudo -H pip3 install ansible
              ansible --version
              echo "Ansible installed successfully."
          else
              echo "Ansible is already installed."
          fi
          ansible-playbook -i ansible/hosts.yml ansible/playbook.yml --extra-vars "adminUsername=$(VMUSER)"
        displayName: 'Run Ansible Playbook'
